{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE NoFieldSelectors #-}
{-# LANGUAGE TypeAbstractions #-}

module ConfigGen where

import Clash.Prelude hiding (Exp, Type)
import Prelude qualified as P

import Clash.Annotations.Primitive
import Clash.Backend
import Clash.Core.Term
import Clash.Core.TermLiteral
import Clash.Core.Type
import Clash.Netlist.BlackBox.Types
import Clash.Netlist.Types
import Clash.Primitives.DSL qualified as DSL

import Control.Lens (view)
import Control.Monad.State (State)
import Data.String.Interpolate (__i)
import GHC.Stack (HasCallStack)
import Prettyprinter (Doc)

import Data.Aeson (ToJSON, encode)
import Data.Data (Proxy (Proxy))
import Data.Either
import Data.Hashable (Hashable, hash)
import Data.Monoid (Ap (getAp))
import Data.Word (Word32)

{- | ILA predicate function
Used to compare incoming data to a reference value (with a possible mask) and returns if the
predicate holds or not. This is used for the ILA trigger and the ILA capture
-}
type Predicate a =
  -- | Incoming sample
  a ->
  -- | Data to compare too
  BitVector (BitSize a) ->
  -- | Sample mask
  BitVector (BitSize a) ->
  -- | Bool indicating if the predicate holds true
  Bool

-- | Same as `Predicate a` but with a string to display in the CLI
type NamedPredicate a = (Predicate a, String)

-- | Default ILA predicate for checking equality
-- It applies the mask over the incoming sample and `==` it with the compare value
ilaPredicateEq :: (BitPack a) => Predicate a
ilaPredicateEq s c m = pack s .&. m == c

-- | Default ILA predicate for checking less-than
-- It applies the mask over the incoming sample and `<` it with the compare value
ilaPredicateLt :: (BitPack a) => Predicate a
ilaPredicateLt s c m = pack s .&. m < c

-- | Default ILA predicate for checking less-than-or-equal-to
-- It applies the mask over the incoming sample and `<=` it with the compare value
ilaPredicateLte :: (BitPack a) => Predicate a
ilaPredicateLte s c m = pack s .&. m <= c

-- | Default ILA predicate for checking greater-than
-- It applies the mask over the incoming sample and `>` it with the compare value
ilaPredicateGt :: (BitPack a) => Predicate a
ilaPredicateGt s c m = pack s .&. m > c

-- | Default ILA predicate for checking greater-than-or-equal-to
-- It applies the mask over the incoming sample and `>=` it with the compare value
ilaPredicateGte :: (BitPack a) => Predicate a
ilaPredicateGte s c m = pack s .&. m >= c

-- | Predefined list of five ILA predicates. The operators it covers are: `==`, `>`, `>=`, `<`, `<=`
ilaDefaultPredicates :: (BitPack a) => Vec 5 (NamedPredicate a)
ilaDefaultPredicates =
  ( (ilaPredicateEq, "Equals")
      :> (ilaPredicateGt, "Greater than")
      :> (ilaPredicateGte, "Greater than or equals")
      :> (ilaPredicateLt, "Less than")
      :> (ilaPredicateLte, "Less than or equals")
      :> Nil
  )

{- | The initial ILA configuration. This record contains all the data needed to create the initial
register map of the ILA.
-}
data IlaConfig dom where
  IlaConfig ::
    forall dom a n m.
    ( KnownNat n
    , KnownNat m
    , NFDataX a
    , BitPack a
    , 1 <= BitSize a `DivRU` 32
    , 1 <= BitSize a
    , 1 <= n
    , 1 <= m
    , m <= 64
    ) =>
    { depth :: SNat n
    -- ^ The amount of samples that can be stored in the buffer
    , triggerPoint :: Index n
    -- ^ How many samples *after* triggering it will continue to sample
    , hash :: BitVector 32
    -- ^ The hash of the ILA, is used to check if the computer is talking to the right ILA
    , tracing :: Signal dom a
    -- ^ The signal being sampled from
    , triggers :: Vec m (Predicate a)
    , capture :: Signal dom Bool
    -- ^ The capture signal
    } ->
    IlaConfig dom

{- | The user provided ILA configuration record. This is used to terminate the creation of an
`IlaConfig` when using `ilaConfig`.
-}
data WithIlaConfig dom a where
  WithIlaConfig ::
    forall dom n m a.
    ( KnownNat n
    , KnownNat m
    , BitPack a
    , 1 <= BitSize a `DivRU` 32
    , 1 <= BitSize a
    , 1 <= n
    , 1 <= m
    , m <= 64
    ) =>
    { name :: String
    -- ^ The name displayed in the VCD file for your toplevel design
    , triggerPoint :: Index n
    -- ^ How many samples *after* triggering it will continue to sample
    , bufferDepth :: SNat n
    -- ^ The amount of samples that can be stored in the buffer
    , triggers :: Vec m (NamedPredicate a)
    , capture :: Signal dom Bool
    -- ^ The capture signal
    } ->
    WithIlaConfig dom a

{- | From a tuple consisting of a signal and a string, grab the bit width of the signal and put it
in a vector. At the same time, bundle every signal together.
-}
class LabeledSignals a where
  ilaProbe :: a

{- | Terminating case
Once encounting a `WithIlaConfig`, terminate collecting of signals and return the `IlaConfig`
generated by the collected signals and labeles.
-}
instance
  forall dom0 dom1 n a b.
  ( NFDataX a
  , BitPack a
  , 1 <= BitSize a `DivRU` 32
  , a ~ b
  , dom0 ~ dom1
  ) =>
  LabeledSignals
    ((Vec n GenSignal, Signal dom0 a) -> WithIlaConfig dom1 b -> IlaConfig dom0)
  where
  ilaProbe ::
    (Vec n GenSignal, Signal dom0 a) ->
    WithIlaConfig dom0 a ->
    IlaConfig dom0
  ilaProbe (signalInfos, tracing) (WithIlaConfig @_ @_ @_ toplevel triggerPoint bufferDepth triggers capture) =
    IlaConfig
      { depth = bufferDepth
      , triggerPoint = triggerPoint
      , hash = ilaHash
      , tracing = tracing
      , triggers = fst <$> triggers
      , capture = capture
      }
   where
    ilaHash = writeSignalInfo toplevel bufferDepth (fromGenSignal <$> signalInfos) (snd <$> triggers)

{- | General case
For every pair of new set of `(Signal dom a, "name")`, bundle the signal and collect the name
into a `Vec`.
-}
instance
  forall dom a b m n next.
  ( m ~ n + 1
  , NFDataX b
  , BitPack b
  , 1 <= BitSize b `DivRU` 32
  , LabeledSignals ((Vec m GenSignal, Signal dom (a, b)) -> next)
  ) =>
  LabeledSignals ((Vec n GenSignal, Signal dom a) -> (Signal dom b, String) -> next)
  where
  ilaProbe ::
    (Vec n GenSignal, Signal dom a) ->
    (Signal dom b, String) ->
    next
  ilaProbe (prevInfos, prevSignal) (newSignal, newName) =
    ilaProbe (prevInfos ++ (newInfo :> Nil), newBundled)
   where
    newInfo = GenSignal{name = newName, width = natToNum @(BitSize b)}
    newBundled = (,) <$> prevSignal <*> newSignal

{- | A polyvariadic function containing 'labeled signals', aka, a list of tuples where the left
side is an arbitary signal, and the right a string. Terminated by a `WithIlaConfig`. The return
type of the function is a `IlaConfig` which should be passed along to the ILA itself.

# Example:

>>> counter = register 0 $ counter + 1 :: Signal dom (Unsigned 8)
>>> indicator = pure True :: Signal dom Bool
>>> config = WithIlaConfig
      { name = "my design"
      , triggerPoint = 0
      , bufferDepth = d100
      , trigger = (==200) <$> counter
      , capture = pure True
      }
>>> ilaConfig (counter, "8 bit value") (indicator, "indicator led light") config
-}
ilaConfig ::
  forall dom a next.
  ( NFDataX a
  , BitPack a
  , 1 <= BitSize a `DivRU` 32
  , LabeledSignals ((Vec 1 GenSignal, Signal dom ((), a)) -> next)
  ) =>
  (Signal dom a, String) ->
  next
ilaConfig (s :: (Signal dom a, String)) =
  ilaProbe (Nil :: Vec 0 GenSignal, pure () :: Signal dom ()) s

-- | Write signal information to a file, using blackboxes
writeSignalInfo ::
  forall n m s.
  -- | Toplevel name
  String ->
  -- | Buffer size
  SNat s ->
  -- | A `Vec` of signal widths and their label
  Vec n (Int, String) ->
  Vec m String ->
  -- | The hash of the JSON
  BitVector 32
writeSignalInfo !_toplevel !_bufSize !_sigInfo !_triggerNames = 0
{-# OPAQUE writeSignalInfo #-}
{-# ANN writeSignalInfo hasBlackBox #-}
{-# ANN
  writeSignalInfo
  ( let
      primitive = 'writeSignalInfo
      template = 'signalInfoBBF
     in
      InlineYamlPrimitive
        [minBound ..]
        [__i|
      BlackBoxHaskell:
        name: #{primitive}
        templateFunction: #{template}
        workInfo: Always
    |]
  )
  #-}

-- | The write signal blackbox function, grabs the AST from the context it gets invoked in
signalInfoBBF :: (HasCallStack) => BlackBoxFunction
signalInfoBBF _ _ args _ = view tcCache >>= go
 where
  go tcm
    | [toplevel, _, sigInfo, triggerNames] <- lefts args
    , [ (coreView tcm -> LitTy (NumTy n))
      , (coreView tcm -> LitTy (NumTy m))
      , (coreView tcm -> LitTy (NumTy s))
      ] <- rights args
    , Just (SomeNat (Proxy :: Proxy n)) <- someNatVal n
    , Just (SomeNat (Proxy :: Proxy m)) <- someNatVal m
    , Just (SomeNat (Proxy :: Proxy s)) <- someNatVal s =
        mkBlackBox $ getGenIla @n @m @s
          toplevel
          (SNat @s)
          (getSigInfo sigInfo)
          (coerceToType triggerNames "cry")
    | otherwise = errorX "Improper data given, expected Vec n (Int, String)"

  -- \| Make the actual blackbox
  mkBlackBox input = pure $ Right (blackBoxMeta input, blackBox input)

  -- \| Coerce a `Term` back into a type
  -- Panics on failure
  coerceToType ::
    (TermLiteral a) =>
    -- \| The AST of the type
    Term ->
    -- \| Error label, to be displayed if coercion fails
    String ->
    -- \| The result type
    a
  coerceToType term err = case termToData term of
    Left _ -> errorX [__i|Cannot coerce term into an #{err}, cannot write ILA config|]
    Right v -> v

  -- \| Get the signal information from it's AST form
  getSigInfo :: forall n. (KnownNat n) => Term -> Vec n (Int, String)
  getSigInfo term = coerceToType term "signal info"

  -- \| Generate the ILA from the AST
  getGenIla ::
    forall n m s.
    ( KnownNat n
    , KnownNat m
    , KnownNat s
    ) =>
    Term ->
    SNat s ->
    Vec n (Int, String) ->
    Vec m (String) ->
    GenIla
  getGenIla toplevel bufSize sigInfo triggerNames  =
    GenIla
      { toplevel = coerceToType toplevel "toplevel name"
      , bufferSize = snatToNum bufSize
      , hash =
          fromIntegral
            $ hash
              ( coerceToType toplevel "toplevel name" :: String
              , snatToInteger bufSize
              , toList sigInfo
              )
      , -- The reverse is needed as the polyvariadic function builds up the vector in reverse order
        signals = P.reverse $ toList $ toGenSignal <$> sigInfo
      , triggerNames = toList triggerNames
      }

  -- \| Meta information about the blackbox
  -- We abuse the `bbIncludes` feature to write our ILA configuration to a JSON file
  blackBoxMeta :: GenIla -> BlackBoxMeta
  blackBoxMeta sizes =
    emptyBlackBoxMeta
      { bbKind = Clash.Netlist.BlackBox.Types.TExpr
      , bbIncludes =
          [
            ( ("ilaconf", "json")
            , BBFunction (show 'renderJSONTF) 0 (renderJSONTF sizes)
            )
          ]
      }

  -- \| The blackbox itself, which we don't use as we only want to write to meta files
  blackBox :: GenIla -> BlackBox
  blackBox sizes = BBFunction (show 'renderHDLTF) 0 (renderHDLTF sizes)
{-# NOINLINE signalInfoBBF #-}

{- | Template function to generate HDL
As we only want to write JSON, this is simply an empty string
-}
renderHDLTF :: (HasCallStack) => GenIla -> TemplateFunction
renderHDLTF args = TemplateFunction [] (const True) (renderHDL args)
{-# NOINLINE renderHDLTF #-}

-- | Template function to generate JSON
renderJSONTF :: (HasCallStack) => GenIla -> TemplateFunction
renderJSONTF args = TemplateFunction [] (const True) (renderJSON args)
{-# NOINLINE renderJSONTF #-}

-- | Calculate the hash over the file contents and return it as a number
renderHDL ::
  forall s.
  ( HasCallStack
  , Backend s
  ) =>
  -- | The Ilas to encode to get the hash from
  GenIla ->
  -- | Unused
  BlackBoxContext ->
  -- | The output JSON content
  State s (Doc ())
renderHDL ila _ = getAp $ expr True (DSL.bvLit 32 $ toInteger ila.hash).eex

-- | Actually render JSON
renderJSON ::
  forall s.
  ( HasCallStack
  , Backend s
  ) =>
  -- | The Ilas to encode to JSON
  GenIla ->
  -- | Unused
  BlackBoxContext ->
  -- | The output JSON content
  State s (Doc ())
renderJSON ila _ = pure [__i|#{encode ila}|]
{-# NOINLINE renderJSON #-}

-- All types primarily just used to properly format a JSON document

-- | Individual signal JSON representation
data GenSignal = GenSignal
  { name :: String
  , width :: Int
  }
  deriving (Generic, Show, ToJSON, Eq, Hashable)

toGenSignal :: (Int, String) -> GenSignal
toGenSignal (w, n) = GenSignal n w

fromGenSignal :: GenSignal -> (Int, String)
fromGenSignal s = (s.width, s.name)

-- | Individual ILA JSON representation
data GenIla = GenIla
  { toplevel :: String
  , bufferSize :: Word32
  , hash :: Word32
  , signals :: [GenSignal]
  , triggerNames :: [String]
  }
  deriving (Generic, Show, ToJSON, Eq, Hashable)
